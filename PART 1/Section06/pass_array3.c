/*
    [문제 21-3]
    [문제 21-2]에서 함수를 하나만 작성해서 하는 방법

    2차원 배열을 인자로 전달받아서 배열에 저장된 모든 요소의 합을 계산하여 그 결과를 반환하는 함수를 정의하고 
    이를 테스트하는 main 함수를 만들자, 테스트에 사용될 배열은 다음과 같다.

    int arr3[2][2] = {1, 3, 5, 7};
    int arr4[2][3] = {1, 2, 3, 4, 5, 6};
    
    1. 21-1과 다르게 필요한 만큼 함수를 만들어도 된다. 
       하나의 함수가 배열 arr3와 arr4의 모든 요소의 합을 각각 계산할 수 있다면 나의 함수만 정의해라.
       그러나 이것이 이치에 맞지 않는다고 판단되면 arr3을 위한 함수와 arr4를 위한 함수를 각각 정의해도 된다.

    [실행의 예]
    1, 3, 5, 7의 합 : 16
    1, 2, 3, 4, 5, 6의 합 : 21
*/

/*
    ! 2차원 배열도 메모리 상에는 1차원 배열과 같기 때문에 sum 함수에서 1차원 배열처럼 접근한다.
    ! 이를 위해서 전달인자를 1차원 배열의 주소 형태로 형변환을 하여 전달한다.

    ! 이 방법은 추천되지 않는다.
    
    ! 이유 1. 함수의 개수가 늘어나는 것은 단점이 아니다. 오히려 프로그램이 명확해 진다는 장점을 얻을 수 있다.
    !       물론 하나의 함수로 충분히 명확하게 구현가능하면서 여러 개의 함수를 작성하는건 어리석은 짓이다.
    
    ! 이유 2. 2차원 배열을 만드는 이유는 2차원적인 사고 및 접근이 필요하기 때문이다. 
    !       2차원 배열을 가지고 1차원적으로 접근한다면 문제 자체를 어렵게 하거나 버그가 발생할 가능성을 높일 수 있다.

    ! 공부하는 관점에서는 칭찬할 일이다.
*/

#include <stdio.h>

int sum(int *arr, int arr_len)
{
    int sum = 0;

    for (int i = 0; i < arr_len; i++)
        sum += arr[i];

    return sum;
}

int main(void)
{
    int arr3[2][2] = {1, 3, 5, 7};
    int arr4[2][3] = {1, 2, 3, 4, 5, 6};
    int result;

    printf("1, 3, 5, 7의 합 = %d\n", sum((int *)arr3, sizeof(arr3) / sizeof(int)));
    printf("1, 2, 3, 4, 5, 6의 합 = %d\n", sum((int *)arr4, sizeof(arr4) / sizeof(int)));

    return 0;
}