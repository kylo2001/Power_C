/*
    [문제 32]
    헤더파일과 전처리기에 대해서 알았으니, 이번에는 컴파일러와 링커에 대해서 이야기 하고자 한다. 

    ? 컴파일러는 파일 단위로 컴파일을 합니다.
    ? 링커는 컴파일러가 컴파일 해놓은 결과물을 하나로 묶어준다.
    ? main 함수를 찾는 일은 링커의 일이다.
    ? main 함수를 찾고 난 다음부터는 전역변수의 접근과 함수의 호출 관계를 파악한다.
    "ddd.obj에서 호출하는 IncNumber 함수는 ccc.obj에 있군!"
    "ddd.obj에서 호출하는 PrintNumber 함수는 bbb.obj에 있군!"

    ? 참고로 실행파일의 이름과 소스파일의 이름은 별개이다. 
    ? 실행파일의 이름이 결정되는 방법은 개발환경에 의해 지정되어 있는데 이는 변경 가능하다.

    * 컴파일러가 파일 단위로 컴파일을 한다는 것은 어떠한 의미인가?
    둘 이상의 파일을 동시에 컴파일 할 때에는 파일 서로간의 연관관계를 전혀 고려하지 않고 컴파일한다는 뜻이다. 
    즉, 다섯 개의 파일을 총 5회에 걸쳐서 각각 컴파일 하건 다섯 개의 파일을 한번에 컴파일을 하건 차이가 전혀 없다.
    결과로 총 다섯 개의 오브젝트 파일을 얻게 될 뿐이다.

    * 선언 "extern int n"이 컴파일러에게 전달하는 메시지는?
    "num은 int형 변수인데 다른 곳에 선언되어 있다. 그러니 num이 있다고 가정하고 컴파일을 진행해라"

    * 선언 "extern int Adder(int a, int b)"이 컴파일러에게 전달하는 메시지는?
    "Adder는 int형 데이터 두 개를 인자로 전달받고 int형 데이터를 반환하는 함수인데 다른 곳에 정의되어 있다. 그러니 함수 Adder가 있다고 가정하고 컴파일을 진행해라."

    * 다음 배열 선언문이 aaa.c에 전역으로(함수 외부에) 선언되었다. 이 때 bbb.c 에서 이 배열에 접근하기 위해 필요한 선언은?
    ! int arr[10];

    extern int arr[10]; 또는 extern int arr[];

    만약 전역으로 이차원 배열이 선언되었다면??
    int arr[5][7];

    extern int arr[5][7]; 또는 extern int arr[][7];

    * 링커가 하는 일을 한 문장으로 정리한다면?
    "링커는 하나 이상의 오브젝트 파일을 묶어서 하나의 실행파일을 만든다."
*/
